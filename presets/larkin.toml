[header]
version = "1.0"
name = "Larkin"
description = """
# Larkin Keybindings

This set of keybindings provides a comprehensive and well tested set of
bindings that I use in my daily work. It serves as an example of a fully
customized set of keybindings, and demonstrates the full capabilities of
ModalKeys.

The basic logic of these commands follow that of Kakoune: motions generally
cause some region of text to be selected, and then actions modify these
selections. This is the inverse of vim's motions (`wd` instead of `dw`). This
integrates well with many of the existing VSCode extensions which operate on
selections. 

These bindings are named after the middle name of my first child.
"""

extensions = [
    "dbankier.vscode-quick-select",
    "haberdashPI.vscode-select-by-indent",
    "haberdashPI.selection-utilities",
    "haberdashPI.move-cursor-by-argument",
    "pustelto.bracketeer",
    "wmaurer.change-case",
    "pranshuagrawal.toggle-case",
    "albymor.increment-selection",
    "pkief.markdown-checkbox",
    "edgardmessias.clipboard-manager",
    "stkb.rewrap",
    "haberdashPI.terminal-polyglot",
    "jack89ita.open-file-from-path",
    "koalamer.labeled-bookmarks",
]

## Implementation notes:
# when these get expanded into actual keybindings I need to:
# 0. validate and expand all items to types
# 1. DONE Expand all `default` keys into the individual keybindings
# 2. DONE replace any instances of {key} as appropriate, by iterating over `keys`
# 3. DONE flatten all bindings into a single sequence
# 6. For any entries that are duplicate bindings with distinct when clauses (before the
#    transformations applied below) make sure that `name` and `description` are identical
#    or blank, and use the non-blank value in all instances
# 4. DONE Wrap all bare commands in `modalkeys.commands` (or should it be called something else)
#   as this will record all actions and it will replace all instances of `{variable}` with
#   the actual value (e.g. `{count}`) before running the command when the command is
#   actually run. Don't do anything if the command already is `modalkeys.commands`. It will
#   also clear the count. (OR could only wrap commands that include these special
#   variables).
# 5. Transform "allowed_prefix": we need to create two commands, one with and one without
#    the prefix
# 6. take any multi-key bindings and turn them into single keybindings that call
#   `modalkeys.prefix` and append a prefix to the modal keys state the prefix becomes part
#   of the when clause for suffixes of the binding
# 7. Any uses of `mode` get moved into the when clause, checking for `modalkeys.mode`
# 8. any non-prefix keys include the empty prefix check in their when clause
# 9. translate the name and description into helpful comments 
#    in the bindings file (and remove them form the object)

# TODO: when implementing `modalkeys.do` we can use JSEP to parse 
# expressions for the `computedArgs` value: https://github.com/EricSmekens/jsep

[bind.motion]
name = "Motions"
kind = "select"
default.mode = "normal"

[bind.count]
name = "count"
description = """
The number keys are used to update the count, which affects how many times the next 
command is repeated, when relevant.
"""

[[bind.count.items]]
keys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
command = "modalkeys.updateCount"
args.value = "{key}"
mode = "!insert" # number keys apply in all modes but insert

[bind.motion.prim]
name = "Primitive Motions"
description = "Motions fundamental to moving around in the editor."
default.command = "modalkeys.cursorMove"
default.computedArgs.value = "count"
default.computedArgs.around = "around_on"
default.computedArgs.select = "select_on"

[[bind.motion.prim.items]]
key = "h"
name = "←"
description = "move left"
args.to = "left"

[[bind.motion.prim.items]]
key = "j"
name = "↓"
description = "move down"
args.to = "down"

[[bind.motion.prim.items]]
key = "k"
name = "↑"
description = "move up"
args.to = "up"

[[bind.motion.prim.items]]
key = "l"
name = "→"
description = "move right"
args.to = "right"

[[bind.motion.prim.items]]
key = "g j"
name = "unwrp ↓"
description = "down unwrapped line"
args.to = "down" 
args.by = "line"

[[bind.motion.prim.items]]
key = "g k"
name = "unwrp ↑"
description = "up unwrapped line"
args.to = "down" 
args.by = "line"

[bind.motion.mod]
name = "Modify Motion Effects"
description = "Keys that change how other motions work"
kind = "select"

[[bind.motion.mod.items]]
key = "u"
name = "around"
description = """
selection commands are changed to both move start and end of a selection to surround the 
entire object (rather than extending to specified start/end point)
"""
command = "modalkeys.prefix"
args = { key = "u", label = "around" }

[[bind.motion.mod.items]]
key = "space"
name = "hold selection"
description = """
selection commands extend the selection
"""
command = "modalkeys.flag"
args.flag = "select_on"
args.value = "toggle"

[bind.motion.obj]
name = "Motions around various regex-like objects"
description = """
selection commands that move by a predefined syntactic object (e.g. word, paragraph, etc...)
"""
default.command = "selection-utilities.moveBy"
default.args.boundary = "start"
default.allowed_prefix = "u"
default.computedArgs.select = "select_on && !around_on"
default.computedArgs.selectWhole = "around_on"

[[bind.motion.obj.items]]
key = "w"
name = "subwrd →"
description = "next subword (camel/snake case)"
args.unit = "subword"
computedArgs.value = "count"

[[bind.motion.obj.items]]
key = "e"
name = "subwrd end"
description = "next subword (camel/snake case) end"
args.unit = "subword"
computedArgs.boundary = "around_on ? 'both' : 'end'"
computedArgs.value = "count"

[[bind.motion.obj.items]]
key = "W"
name = "word →"
description = "next word"
args.unit = "word"
computedArgs.value = "couht"

[[bind.motion.obj.items]]
key = "E"
name = "word end"
description = "next word end"
args.unit = "word"
computedArgs.boundary = "around_on ? 'both' : 'end'"
computedArgs.value = "count"

[[bind.motion.obj.items]]
key = "b"
name = "subwrd ←"
description = "previous subword (camel/snake case)"
args.unit = "subword"
computedArgs.value = "-count"

[[bind.motion.obj.items]]
key = "B"
name = "word ←"
description = "previous word"
args.unit = "word"
computedArgs.value = "-count"

[[bind.motion.obj.items]]
key = "u u"
name = "smart expand"
description = "Use VSCode's built-in smart expansion command"
command = "editor.action.smartSelect.expand"

[bind.motion.search]
name = "Search Related Motions"
description = "Motions related to searching for text in a document"
default.command = "modalkeys.search"
default.args.caseSensitive = true
default.args.backwards = false
default.args.selectTillMatch = true
default.args.wrapAround = true

[[bind.motion.search.items]]
key = "/"
name = "search"
description = "search forwards"

[[bind.motion.search.items]]
key = "?"
name = "search bk"
description = "search backwards"
args.wrapAround = true

[[bind.motion.search.items]]
key = "f"
name = "find char"
description = "Find the next char (include char in selection)"
args.acceptAfter = 1
computedArgs.skip = "count-1"

[[bind.motion.search.items]]
key = "F"
name = "find char back"
description = "Find the previous char (include char in selection)"
args.acceptAfter = 1
args.backwards = true
computedArgs.skip = "count-1"

[[bind.motion.search.items]]
key = "t"
name = "to char"
description = "Find the next char (exclude char in selection)"
args.acceptAfter = 1
args.offset = "start"
computedArgs.skip = "count-1"

[[bind.motion.search.items]]
key = "T"
name = "to char back"
description = "Find the previous char (exclude char in selection)"
args.acceptAfter = 1
args.offset = "end"
args.backwards = true
computedArgs.skip = "count-1"

[[bind.motion.search.items]]
key = "s"
name = "find char pair"
description = "To next character pair"
args.acceptAfter = 2
args.offset = "start"

[[bind.motion.search.items]]
key = "S"
name = "char pair back"
description = "To previous character pair"
args.acceptAfter = 2
args.offset = "start"

[[bind.motion.search.items]]
key = ";"
label = "→ match"
description = "Repeat search motion forwards"
command = "modalkeys.nextMatch"
computedArgs.repeat = "count"

[[bind.motion.search.items]]
key = ":"
label = "← match"
description = "Repeat search motion backwards"
command = "modalkeys.previousMatch"
computedArgs.repeat = "count"

[bind.motion.syntax]
label = "Motions around syntactic objects (e.g. parentheses and quotes)"
description = """
selection commands that move by a predefined syntactic object like brackets and quotes
"""

[[bind.motion.syntax.items]]
key = "{"
label = "arnd parens"
description = "parens/brackets/braces and their contents"
command = "selection-utilities.expandAroundBrackets"

[[bind.motion.syntax.items]]
key = "["
label = "in parens"
description = "text inside parens/brackets/braces"
command = "selection-utilities.expandInBrackets"

[bind.action]
label = "Actions"
kind = "action"

[bind.action.basic]
label = "Basic Actions"
description = "Essential actions required to edit text"

[[bind.action.basic.items]]
# TODO: add documentation to these basic editor keys
key = "i"
name = "insert"
description = "Switch to insert mode (right before character)"
commands = ["modalkeys.shrinkSelections", "modalkeys.enterInsert"]

[[bind.action.basic.items]]
key = "a"
name = "append"
description = "Switch to insert mode (right after character)"
commands = ["modalkeys.shrinkSelections", "modalkeys.enterInsert"]
when = "editorHasSelection"

[[bind.action.basic.items]]
key = "a"
commands = ["modalkeys.shrinkSelections", "cursorRight", "modalkeys.enterInsert"]
when = "!editorHasSelection"

[[bind.action.basic.items]]
key = "c"
name = "change"
when = "modalkeys.editorHasMultilineSelection"
commands = ["deleteRight", "editor.action.insertLineBefore", "modalkeys.enterInsert"]

[[bind.actions.basic.items]]
key = "c"
when = "!modalkeys.editorHasMultilineSelection && editorHasSelection"
commands = ["deleteRight", "modalKeys.enterInsert"]

[[bind.actions.basic.items]]
key = "c"
when = "!editorHashSelection && modalkeys.count <= 1"
commands = ["expandLineSelection", "deleteRight", "editor.action.insertLineBefore", 
            "modalkeys.enterInsert" ]

[[bind.actions.basic.items]]
key = "c"
when = "!editorHasSelection && modalkeys.count > 1"
commands = [{command = "modalkeys.selectLines", computedArgs = {value = "count"}},
            "deleteRight",
            "editor.action.insertLineBefore",
            "modalkeys.enterInsert"]

[[bind.actions.basic.items]]
key = "C"
label = "change to/back"
description = """Without a count: change from current char to end of line. With a count: 
change the previous `count` lines.
"""
when = "!modalkeys.count <= 1"
commands = ["modalkeys.shrinkSelections", "deleteAllRight", "modalkeys.enterInsert"]

[[bind.actions.basic.items]]
key = "C"
when = "!modalkeys.count > 1"
commands = [{command = "modalkeys.selectLines", computedArgs = {value = "count"}, dir = "up"}, 
            "deleteRight", "editor.actions.insertLineBefore", "modalkeys.enterInsert"]

[[bind.actions.basic.items]]
key = "d"
label = "delete"
description = """
Without a count: delete selected text (and store to clipboard). With a 
count, delete up to the next `count` lines and store to clipboard.
"""
when = "!editorHasSelection"
commands = [{command = "modalkeys.selectLines", computedArgs = {value = "count"}},
             "editor.action.clipboardCutAction",
            {command = "modalkeys.enterMode", value = "normal"}]

[[bind.actions.basic.items]]
key = "d"
when = "editorHasSelection"
commands = ["editor.action.clipboardCutAction",
            {command = "modalkeys.enterMode", value = "normal"}]

[bind.actions.symmetric]
name = "Symmetric Operations"
description = "Operations that occur at both ends of a selection"
kind = "select"
default.mode = "syminsert"

[[bind.actions.symmetric.items]]
name = "Symmetric Insert Mode"
description = """
In this mode all commands and character insertions happen at both ends of 
the selection
"""
mode = "normal"
key = "g '"
command = "modalkeys.enterMode"
args.mode = "syminsert"

[[bind.actions.symmetric.items]]
name = "Normal"
description = "Return to normal model"
keys = ["enter", "g '"]
command = "modalkeys.enterMode"
args.mode = "normal"

[[bind.actions.symmetric.items]]
keys = [":", ";", "'", '"', ",", ".", "/", "?", "|", "=", "+", "-", "_", "*", "&", "^", "%", 
        "$", "#", "@", "!", "`", "~"]
description = "Insert the character {key} at both ends of each selection"
command = "selection-utilities.insertAround"
args = { before = "{key}", after = "{key}"}


